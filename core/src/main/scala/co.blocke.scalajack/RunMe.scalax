package co.blocke.scalajack

import scala.reflect.runtime.universe._

case class MapFactorId(
    @DBKey @MapName(name = "foo_bar") fooBar:String,
    @MapName(name = "a_b") thingy:         Long,
    count:                                 Int,
    @MapName(name = "big_mac") bigMac:     String)

object RunMe extends App {

  val p = MapFactorId("Greg", 52L, 3, "ooo")
  doSomething(p)

  def doSomething(x: MapFactorId)(implicit tt: TypeTag[MapFactorId]): Unit = {
    val classSymbol = tt.tpe.typeSymbol.asClass
    val constructorSymbol = classSymbol.primaryConstructor.asMethod

    val params1 = constructorSymbol.typeSignatureIn(tt.tpe).paramLists.flatten

    println(params1)

    params1.map { member =>
      println("DBKey: " + getAnnotationValue[DBKey, Int](member, 0))

      val mapAnnotation = member.annotations.find(_.tree.tpe =:= typeOf[MapName])
      val result2 = (member.name.toString, mapAnnotation.flatMap { a =>
        a.tree.children.tail.head.collect({
          case Literal(Constant(value)) => value
        }).headOption
      })
      println(result2)

      println("---------")
    }

    println("Collection: " + getAnnotationValue[Collection, String](classSymbol, "P"))

  }

  def getAnnotationValue[T, U](sym: Symbol, default: U)(implicit tt: TypeTag[T]): Option[U] = {
    val annotation = sym.annotations.find(_.tree.tpe =:= typeOf[T])
    annotation.flatMap { a =>
      if (a.tree.children.tail.size == 0)
        Some(default)
      else
        a.tree.children.tail.head.collect({
          case Literal(Constant(value)) => value
        }).headOption
    }.asInstanceOf[Option[U]]
  }
}

